---
title: 01-Golang基础
author: 菠萝
email: 2493381254@qq.com
readmore: true
hideTime: true
categories: GoGuide
tag: Goguide
date: 2024-05-04 16:54:41
abbrlink: 
---
# Golang基础知识
> 更新中...

## OOP思想
> 如何回答呢？
>
> 1. 首先我们肯定要讲出面向对象的三个特性：a.封装 b.继承 c.多态
>
> 2. 接下来我们详细说一下这三个特性。
>
> - 封装：封装的意义，在于明确标识出允许外部使用的所有成员函数和数据项，或者叫接口。
>
> - 继承：
>    继承基类的方法，并做出自己的扩展；
>    声明某个子类兼容于某基类（或者说，接口上完全兼容于基类），外部调用者可无需关注其差别（内部机制会自动把请求派发dispatch到合适的逻辑）。
>
> - 多态：基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同。很显然，多态实际上是依附于继承的第二种含义的。
>
> 其实一般说到这里就可以了，当然我们也可以举一些例子。（其实对于封装和继承很好理解，这个例子基本上不用，那么我们可以举一些多态的例子）
>
> 什么是多态呢？这时候我们可以举一下子，**重写**和**重载**。基本上把这两个说好就可以了。


## slice
当前引用下会把相关面试问题回答，后续是一些相关知识

> slice经常会问到的题目？
> 
> 一、slice的扩容过程？
> 
> 对于这个问题，我们要理清思路，讲到扩容，对于slice这种比较简单的结构：
> 1. 讲一下slice的数据结构，它有三个字段， array(一个指针，指向底层的数组),len(当前slice里面存放的个数),cap(就是当前slice的容量，最多存放多少数据)
> 2. 接下来，讲一下。什么情况下发生扩容，必然是当我们调用 append()函数，向slice中添加数据的时候，才会出现，存放不下的情况，那么我们就需要扩容了。
> 3. 接下来，就是需要讲扩容的规则(这部分网上基本上都有，我们可以简述一下扩容规则，注意，其实在双倍扩容的时候会去比较，cap+newNum > 2*cap,如果大于，则直接newCap=cap+newNum)
> - golang1.18版本之前：当 cap < 1024的时候，采用双倍扩容；当 cap > 1024的时候，采用1.25倍的扩容机制。
> - golang1.18版本之后：当 cap < 256的时候，采用双倍扩容；当 cap > 256的时候，采用 newCap = oldCap + (oldCap+3*256)/4。
> - 最后，我们可以再说一下，其实在go中，由于内存对齐机制的存在，容扩最后会调用，runUpSize()最终来计算得到，计算结果一般要 >= 之前的cap。

### slcie的数据结构
- slice 的底层数据是数组，slice 是对数组的封装，它描述一个数组的片段
- 数组是定长的，长度定义好之后，不能再更改。
- 数组就是一片连续的内存， slice 实际上是一个结构体，包含三个字段：长度、容量、底层数组。

~~~go
// runtime/slice.go
type slice struct {
    array unsafe.Pointer // 元素指针
    len   int // 长度 
    cap   int // 容量
}
~~~


## map

## channel

## Context

## GPM模型

## 接口

## GC

## TCmalloc

## 
